/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from 'react'
import { useGLTF, Bounds, useBounds } from '@react-three/drei'
import * as THREE from "three"




export default function LegoModel({ ...props }) {


  const group = useRef()

  const { streetData, greenAreaData, institutionData, residentialData, officeData, waterData, bridgeData } = require("./BuildingData")

  const [hoveredBuilding, hoverBuilding] = useState(false)
  const [hoveredOffice, hoverOffice] = useState(false)
  const [hoveredStreets, hoverStreet] = useState(false)
  const [hoveredBridge, hoverBridge] = useState(false)
  const [hoveredGreenspace, hoverGreenspace] = useState(false)
  const [hoveredResidential, hoverResidential] = useState(false)
  const [hoveredWater, hoverWater] = useState(false)

  const { nodes, materials } = useGLTF('/models/cut_model.gltf')
  //const { nodes, materials } = useGLTF('/models/legomodel.gltf')

  const basematerial = new THREE.MeshPhysicalMaterial({ color: "#0A1B2A" })
  const hoverMaterialPrimary = new THREE.MeshPhysicalMaterial({ color: "#A3C4FF" })
  const hoverMaterialSecondary = new THREE.MeshPhysicalMaterial({ color: "#465166" })



  //Dialogue management
  function handleClickOpen(data) {
    props.onHandleDialog(true, data);
  };

  function shadowActive() {
    if (props.activeSimulation == "shadow") {
      return true
    } else {
      return false
    }
  }

  function windDirection() {
    let direction = (-props.windDirection / 360 * 6.3 - Math.PI / 4)
    return direction
  }

  const flag_x = 0
  const flag_y = 0

  function SelectToZoom({ children }) {
    const api = useBounds()
    return (
      <group onClick={(e) => (e.stopPropagation(), e.delta <= 2 && api.refresh(e.object).fit())} onPointerMissed={(e) => e.button === 0 && api.refresh().fit()}>
        {children}
      </group>
    )
  }

  return (
    <group ref={group} {...props} dispose={null} >
      {/* GROUND PLATE 
      <mesh geometry={nodes.ground_plate_dark_grey.geometry} material={basematerial} position={[0, 8, 0]} rotation={[-Math.PI / 2, 0, 0]} />
*/}

      {/* INSTITUTION 
      <group position={[-50, 8, 50]} rotation={[-Math.PI / 2, 0, 0]} onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverBuilding(true)} onPointerOut={(event) => hoverBuilding(false)} onClick={(event) => handleClickOpen(institutionData)}>
        <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.institution_white.geometry} material={hoveredBuilding ? hoverMaterialPrimary : materials.white} position={[-10, 0, 8]} rotation={[0, 0, -Math.PI / 2]} />
        <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.instituion_grey.geometry} material={hoveredBuilding ? hoverMaterialSecondary : materials.light_grey} position={[-20, 0, 40]} rotation={[0, 0, -Math.PI / 2]} />
      </group>
*/}
      {/* BRIDGE 
      <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.bridge_white.geometry} material={hoveredBridge ? hoverMaterialPrimary : materials.white} position={[60, 40, 20]} rotation={[-Math.PI / 2, 0, 0]} onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverBridge(true)} onPointerOut={(event) => hoverBridge(false)} onClick={(event) => handleClickOpen(bridgeData)} />
*/}

      {/* GREEN SPACE
      <group onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverGreenspace(true)} onPointerOut={(event) => hoverGreenspace(false)} onClick={(event) => handleClickOpen(greenAreaData)}>
        <mesh receiveShadow={shadowActive()} geometry={nodes.urban_green_green.geometry} material={hoveredGreenspace ? hoverMaterialPrimary : materials.green} position={[20, 24, -60]} rotation={[-Math.PI / 2, 0, -Math.PI / 2]} />
        <mesh receiveShadow={shadowActive()} geometry={nodes.urban_green_dark_green.geometry} material={hoveredGreenspace ? hoverMaterialPrimary : materials.dark_green} position={[60, 16, 60]} rotation={[-Math.PI / 2, 0, 0]} />
        <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.urban_green_light_green.geometry} material={hoveredGreenspace ? hoverMaterialPrimary : materials.light_green} position={[60, 48, 60]} rotation={[-Math.PI / 2, 0, 0]} />
        <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.urban_green_brown.geometry} material={hoveredGreenspace ? hoverMaterialSecondary : materials.reddish_brown2} position={[60, 40, 60]} rotation={[-Math.PI / 2, 0, 0]} />
      </group>
 */}
      {/* WATER 
      <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.water_blue.geometry} material={hoveredWater ? hoverMaterialPrimary : materials.azure_blue} position={[60, 16, 20]} rotation={[-Math.PI / 2, 0, 0]} onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverWater(true)} onPointerOut={(event) => hoverWater(false)} onClick={(event) => handleClickOpen(waterData)} />
*/}
      {/* RESIDENTIAL BUILDING
      <group position={[-30, 8, -40]} rotation={[-Math.PI / 2, 0, 0]} onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverResidential(true)} onPointerOut={(event) => hoverResidential(false)} onClick={(event) => handleClickOpen(residentialData)}>
        <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.residential_walls.geometry} material={hoveredResidential ? hoverMaterialPrimary : materials.brick_yellow} position={[-30, -30, 64]} />
        <group position={[10, 0, 80]} rotation={[0, 0, -Math.PI / 2]}>
          <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.Mesh_3299dat_70001.geometry} material={hoveredResidential ? hoverMaterialSecondary : materials.reddish_brown2} />
          <mesh castShadow={shadowActive()} receiveShadow={shadowActive()} geometry={nodes.Mesh_3299dat_70001_1.geometry} material={hoveredResidential ? hoverMaterialSecondary : materials.reddish_brown2} />
        </group>
      </group>
 */}
      {/* OFFICE BUILDING */}
      <group position={[0, 0, 0]} rotation={[-Math.PI / 2, 0, 0]} onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverOffice(true)} onPointerOut={(event) => hoverOffice(false)} onClick={(event) => handleClickOpen(officeData)}>
        <mesh geometry={nodes.base.geometry} material={basematerial} position={[0, 0, 0]} rotation={[0, 0, 0]} />
        <mesh geometry={nodes.firstfloor.geometry} material={basematerial} position={[0, 0, 0]} rotation={[0, 0, 0]} />
      </group>

      {/* FLAG 
      <group >
        <mesh castShadow={shadowActive()} geometry={nodes.flag_port_white.geometry} material={materials.white} position={[60, 144, -20]} rotation={[-Math.PI / 2, 0, 0]} />
        <group position={[60, 0, -20]} rotation={[0, windDirection(), 0]}>
          
          <mesh castShadow={shadowActive()} geometry={nodes.flag_white.geometry} material={materials.white} position={[flag_x, 223.31, flag_y]} rotation={[-Math.PI / 2, 0, -2.44]} />
          <group position={[flag_x + 21.23, 203.49, flag_y + 21.45]} rotation={[-Math.PI / 2, 0, -0.88]} scale={-45.92}>
            <mesh geometry={nodes.SocialMedia_Black_1.geometry} material={materials.SocialMedia_Black} />
            <mesh geometry={nodes.SocialMedia_Black_2.geometry} material={materials['__CUT_Logo_monofarbig_dunkelblau mini']} />
          </group>
        </group>
      </group>
      */}

      {/* STREETS 
      <group onPointerOver={(event) => props.activeSimulation == null  && props.view.name != "pedestrian"&& hoverStreet(true)} onPointerOut={(event) => hoverStreet(false)} onClick={(event) => handleClickOpen(streetData)}>
        <mesh receiveShadow={shadowActive()} geometry={nodes.streets_dark_grey.geometry} material={hoveredStreets ? hoverMaterialPrimary : materials.dark_grey} position={[20, 16, -50]} rotation={[-Math.PI / 2, 0, 0]} />
        <mesh receiveShadow={shadowActive()} geometry={nodes.streets_black.geometry} material={hoveredStreets ? hoverMaterialPrimary : materials.black} position={[20, 16, 20]} rotation={[-Math.PI / 2, 0, 0]} />
      </group>
*/}

    </group>
  )
}

useGLTF.preload('/models/cut_model.gltf')

